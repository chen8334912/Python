# python = ['lcg','szw','zjw']
# linux = ['lcg']
#
# # he = []
# # for i in python:
# #     if i in linux:
# #         he.append(i)
# # print(he)
# chris = set(python)
# chris.update('1','2','4')
# print(chris)

# msg = 'i am %s %s %.4f %.4s' % ('chris','df',99.234561213,'lksdjfl;kskjaf')
# print(msg)
# tpl = 'i am %(name)s age %(age)d ' %{'name':'alex', 'age':19}
# print(tpl)
# tps1 = 'i am %(name)-60s  my hobby is alex' % {'name':'lhf'}
# print(tps1)
# tps2 = 'i am %(name)+60s  my hobby is alex' % {'name':'lhf'}
# print(tps2)
# tps3 = 'i am %(name)+60s  my hobby is alex' % {'name':'lhf'}
# print(tps3)
# tpl4 = 'i am {1}'.format('chris', 'dkslj')
# print(tpl4)
# tpl5 = 'i am {name}, age {age}, really{go}'.format(name = 'chris',age = 11,go = 11)
# tpl5 = 'i am {name}, age {age}, really{go}'.format(**{'name': 'chris','age' : 11,'go' : 11})
# tpl5 = "i am {0[0]}, age {0[1]}, really {0[2]}".format([1, 2, 3], [11, 22, 33])
# tpl = "i am {:s}, age {:d}, money {:f}".format("seven", 18, 88888.1)
# tpl = 'i am {:s}, age {:d}'.format(*['seven', 1])
# print(tpl)



# def chris(x):
#     y = 3*x+12
#     return y
# chris(3)

# print(list(zip(('a', 'b', 'c', 'd'),(1, 2, 3, 4))))
# p = {'name':'alex', 'age':18, 'gril':'sadf'}
# print(dict(zip(p.keys(),p.values())))
# print(list(zip(p.keys(),p.values())))
# print(tuple(zip(p.keys(),p.values())))


# age_dic={'age1':18, 'age2':28, 'age9':48, 'age4':88}
# # print(max(age_dic.values()))
# # print(max(age_dic))
# chris = max(zip(age_dic.values(),age_dic.keys()))
# print(chris)

# l1= ['a10', 'b12', 'c12']
# print(list(max(l1)))

# a = [1,2,3]
# b = [4,5,6]
# c = [4,5,6,7,8]
# print(list(zip(a,b)))     # 打包为元组的列表
# # >>> zip(a,c)              # 元素个数与最短的列表一致
# # [(1, 4), (2, 5), (3, 6)]
# # >>> zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式
# # [(1, 2, 3), (4, 5, 6)]

# people = [
#     {'name' : 'chris1', 'age' : 1000},
#     {'name' : 'chris2', 'age' : 10000},
#     {'name' : 'chris3', 'age' : 100000},
#     {'name' : 'chris11', 'age' : 10000000},
# ]
# print(max(people, key=lambda dic:dic['name']))

# ret= []
# for i in people:
#     ret.append(i['age'])
# print(ret)
# print(max(ret))


# def odd(x):
#     return x % 2
#
# temp = filter(odd, range(10))
# print(list(temp))

#
# print(list(filter(lambda x: x % 2 , range(10))))
# print(list(map(lambda x: x * 2, range(10))))


# def factorial(digital):
#     result = digital
#     for i in range(1 , digital):
#         result *= i
#     return result
#
# digital = 5
# result = factorial(digital)
# print('%d factorial is %d' % (digital, result))

# digital = int(input('input:'))
# def factorial(digital):
#     if digital == 1:
#         return 1
#     else:
#         return digital * factorial(digital-1)
# res = factorial(digital)
# print(res)

# def hanoi(n, x, y, z):
#     if n == 1:
#         print(x,'--->',z)
#     else:
#         hanoi(n-1, x, z, y)
#         print(x, '--->', z)
#         hanoi(n-1,y,x,z)
# n = 4
# hanoi(n,'x','y','z')

# dict1 = dict(f=70, i=103, s=115)
# dict1['x']='ss'
# dict1['f']='ss'
# print(dict1)

# from web.web1.web2.cal import add       # 执行__init__文件
#
# add(3,5)


'''''
时间模块

import time, sys, datetime
print(sys.path)
print(time.time())        # 时间戳, 返回当前时间的时间戳（1970纪元后经过的浮点秒数）
print(time.localtime())       # 格式化时间戳, 格式化时间戳为本地的时间，结构化时间---当地时间，time.localtime(time.time)
t = time.localtime()
print(t.tm_mday)
print(time.gmtime())       # 格式化时间戳, 格式化时间戳为UTC时间，结构化时间---UTC时间（世界标准时间）
print(time.mktime(time.localtime()))        # 结构化时间转换成时间戳
print(time.strftime('%Y - %m - %d %X', time.localtime()))        # 结构化时间转换成字符串时间，年大写，时分秒大写的X
print(time.strptime('2019 - 07 - 19 13:56:21','%Y - %m - %d %X'))        # 字符串时间转换成结构化时间
print(time.asctime())               #  将时间元组转换为字符串。“1998年6月6日星期六16:26:11”。如果时间元组不存在，则使用localtime()返回的当前时间。
print(time.ctime(156351988))        #  将纪元以来的时间(以秒为单位)转换为本地时间中的字符串。这相当于asctime(localtime(seconds))。如果时间元组不存在，则使用localtime()返回的当前时间。
print(datetime.datetime.now())


'''''

'''''
random模块


随机生成五位密码1

import random

def v_code():
    ret = ''
    for i in range(5):
        num = random.randint(0,9)
        lif = chr(random.randint(65,122))
        s = str(random.choice([num, lif]))
        ret += s
    return ret
print(v_code())




随机生成五位密码2

import random
def v_code():
    ret = ''
    for i in range(13):
        num = random.randint(0,122)
        if num < 9:
           num = num
        if num > 65:
            num = chr(num)
        else:
            pass
        s = str(num)
        ret += s
    return ret[:5]
print(v_code())
 
'''''
'''''
# 最后的data["name"]必须是"，因为dumps的时候转成"

import json

with open('/Volumes/Work/Python/wenjian' , 'r') as f :
    data  = json.load(f)
    print(data["name"])

'''''





# 多态

# class H2O:
#     def __init__(self,name,temperature):
#         self.name = name
#         self.temperature = temperature
#     def turn_ice(self):
#         if self.temperature < 0:
#             print('[%s]温度太低结冰了' %self.name)
#         if self.temperature > 0 and self.temperature < 100:
#             print('[%s]液化成水了' % self.name)
#         if self.temperature > 100:
#             print('[%s]温度太高成水蒸气了' % self.name)
#
# class Water(H2O):
#     pass
#
# class Ice(H2O):
#     pass
#
# class Steam(H2O):
#     pass
#
#
# w1 = Water('水',25)
# i1 = Ice('冰',-25)
# s1 = Steam('蒸汽',125)
#
# def func(obj):
#     obj.turn_ice()
# func(w1)

'''''

import modu as md
import sys

print(md)
print(hasattr(md,'chris'))
print(getattr(md,'chris'))


if hasattr(md,'chris'):
    func = getattr(md,'chris')
    func()
else:
    print('no go')

x=1111
fish=sys.modules[__name__]
print(hasattr(fish,'x'))


'''''

'''''



class Foo:
    x=1
    def __init__(self,y):
        self.y=y

    def __getattr__(self, item):
        print('----> from getattr:你找的属性不存在')


    def __setattr__(self, key, value):
        print('----> from setattr')
        # self.key=value #这就无限递归了,你好好想想
        # self.__dict__[key]=value #应该使用它

    def __delattr__(self, item):
        print('----> from delattr')
        # del self.item #无限递归了
        self.__dict__.pop(item)

'''''


'''''

class Foo:
    def __init__(self,age):
        self.n=age

    def __getattr__(self, item):
        print('go go go')
    def __getattribute__(self, item):
        print('bu gou')
        raise AttributeError('has no attribute')
        # raise  TabError('XXXXXXX')

# class Bar(Foo):
#     pass
#
# b1=Bar()
# print(isinstance(b1,Bar))
# print(isinstance(b1,Foo))
# print(type(b1))



f1=Foo(10)
print(f1.n)
# f1.xxx


'''''


'''''

class Goo:
    name='chris'
    def __init__(self,age):
        self.n=age

    def __getitem__(self, item):
        print('getitem',item)
        return self.__dict__[item]

    def __setitem__(self, key, value):
        print('setitem')
        self.__dict__[key]='value'

    def __delitem__(self, key):
        print('delitem')
        self.__dict__.pop(key)

g1=Goo(10)
print(g1.__dict__)


# g1.name='micheal'       # 触发了setatter的内置函数
g1['name']='fish'
g1['sex']='man'
print(g1.__dict__)



g1['name']
print(g1['name'])



# del g1.name       # 触发了delatter的内置函数
del g1['name']
print(g1.__dict__)


print(Goo.__dict__)



'''''


'''''
format_dic={
    'ymd':'{0.year}-{0.month}-{0.day}',
    'mdy':'{0.month}-{0.day}-{0.year}',
    'y:m:d':'{0.year}:{0.month}:{0.day}'
}
class Foo:
    def __init__(self,year,month,day):
        self.year=year
        self.month=month
        self.day=day

    def __format__(self, format_spec):
        print('let us gogogo')
        print(format_spec)
        if not format_spec or format_spec not in format_dic:
            format_spec='mdy'
        fm=format_dic[format_spec]
        return fm.format(self)

d1=Foo(2016,12,22)
# format(d1)
print(format(d1))
print(format(d1,'ymd'))



'''''



'''''

# __slots__:字典会占用大量的内存，如果一个属性很少的类，但有很多的实例，为了节省内存可以使用__slots__来取代实例的__dict__

class Foo:
    __slots__ = 'name'

f1=Foo()
print(f1.__slots__)
#print(f1.__dict__)  # f1不再有__dict__
f1.name='chris'
print(f1.name)
print(f1.__slots__)


class Bar:
    __slots__ = ('name','age')
n=Bar()
n.name='fish'
n.age=18
print(n.__slots__)


'''''

'''''

class Foo:
    def __init__(self,name):
        self.name=name
    def __del__(self):
        print('let us go')
    def __call__(self, *args, **kwargs):
        print('实例执行啦,obh()')

f1=Foo('chris')   # Foo上级的__call__
# del f1.name
f1()   # Foo下的__call__
del f1
print('_____?????')   # 删除实例的时候才会触发__del__
# print(f1.__dict__)
# print(dir(f1))


'''''



'''''
class Foo:
    def __init__(self,age):
        self.age=age
    def __iter__(self):
        return self

    def __next__(self):
        if self.age == 10:
            raise StopIteration('break')
        self.age+=1
        return self.age

f1=Foo(10)

print(f1.__next__())
print(f1.__next__())
print(f1.__next__())
print(f1.__next__())
print(next(f1))
print(next(f1))
print(next(f1))
print(next(f1))

for i in f1:        # obj=iter(f1)----->>f1.__iter__()
    print(i)        # obj.__next__()

'''''



'''''

# 斐波那契数列

# 1 类实现内部魔法方法

class Fibonacci(object):
    def __init__(self,n):
        self.n = n   # 生成数列的个数
        self.current = 0   # 保存当前生成到的数据列的第几个数据，生成器中性质，记录位置，下一个位置的数据
        self.a = 0
        self.b = 1
    def __iter__(self):   # 迭代器的__iter__ 返回自身即可
        return self
    def __next__(self):   # 当使用next()函数调用时，就会获取下一个数
        if self.current < self.n:
            self.a, self.b = self.b , self.a+self.b
            self.current += 1
            return self.a,self.b
        else:
            raise StopIteration('liang le ya')
if __name__ == '__main__':
    f1=Fibonacci(15)
    for i in f1:
        print(i)
        
        

# 2 生成器

def Fib(max):
    a,b = 0,1
    while max > 0:
        a,b = b,a+b
        max-=1
        yield a,b

for i in Fib(11):
    print(i)


'''''
# 实现了 __get__()、__set__()、__del__() 其中至少一个方法的类，就是一个描述符
# 描述符优先级: 类属性--->>>数据描述符--->>>实例属性--->>>非数据描述符--->>>找不到属性触发__getattr__

class Foo:
    def __get__(self, instance, owner):
        print('===>get方法')
    def __set__(self, instance, value):
        print('===>set方法',instance,value)
        instance.__dict__['x']=value #b1.__dict__
    def __delete__(self, instance):
        print('===>delete方法')


class Bar:
    x=Foo() #在何地？
    def __init__(self,n):
        self.x=n #b1.x=10
b1=Bar(10)
print(b1.__dict__)
b1.x=11111111111111111
print(b1.__dict__)
#
b1.y=11111111111111111111111111111111111111
print(b1.__dict__)